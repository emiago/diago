{"/diago/blog/":{"data":{"":"\nWelcome to blog where you can find some interesting topics or how to use some of VOIP stack features."},"title":"_index"},"/diago/blog/sip_unit_testing/":{"data":{"":"","#":"How to UNIT test server First make sure you have imported siptest\nimport \"github.com/emiago/sipgo/siptest\" Example with testing REGISTER request\nfunc handleRegister(req *sip.Request, tx sip.ServerTransaction) { res := sip.NewResponseFromRequest(req, sip.StatusBadRequest, \"Bad Request\", nil) tx.Respond(res) } func TestServerHandlers(t *testing.T) { // Setup server uas, _ := sipgo.NewUA() srv, _ := sipgo.NewServer(uas) srv.OnRegister(handleRegister) // Create request req := sip.NewRequest(sip.REGISTER, sip.Uri{User: \"alice\", Host: \"localhost\"}) // Use dummy client to build request headers uac, _ := sipgo.NewUA() client, _ := sipgo.NewClient(uac) sipgo.ClientRequestBuild(client, req) // Create transaction Recorder txRecord := siptest.NewServerTxRecorder(req) // Run handler and read response handleRegister(req, txRecord) responses := txRecord.Result() require.Len(t, responses, 1) assert.EqualValues(t, 400, responses[0].StatusCode) } "},"title":"sip_unit_testing"},"/diago/docs/":{"data":{"":"Welcome to diago documentation!.","core-roadmap#Core (Roadmap):":" Full dialog control and High Level API alaw,ulaw codecs (opus as third is planned as well) Audio package for streaming: WAV reader/writer, PCM transcoding to alaw/ulaw Playbacks as buffers,files(wav),url Playback URL streaming Playback with control mute/unmute Audio Reader/Writer stream exposed for manual processing like sending to third party DTMF with RTP Handling Reinvites with media updates Bridging as proxy media for 2 parties B2BUA Opus codec support Handling blind transfers (Refers) Handling attended transfers Handle Anonymous Trust Domain PAI handling (rfc3325) Partially Done Conferencing audio DTMF with SIP INFO (Needed more in case webrtc) Writing Unit Test on Server with SIP and Media Recorder RTP symetric SRTP for more critical services Simple Wav Stereo recording Webrtc as media stack (integration with pion) Experimental Full IPV6 support (sipgo work) Supported but has corner cases And plenty more … If you want support/sponzor current development roadmap or you want to prioritize different contact me on mail","diago-extra-modules#Diago extra modules":"Some of modules are not yet considered to be part of lib and they are developed/consulted for private projects. To mention few:\nRecording Webrtc(pion) stack over diago’s media stack Complex modules etc… NEXT: -\u003e Guides","what-is-diago#What is Diago?":"If you are familiar with terms Calling, Bridging, Conferencing, IVR, Recording, Transcribing, Voicemail … that is all about.\nDeveloping this kind of services can be challenging when it needs more behavior: monitoring, media control, integrations, databases etc…\nDiago with GO offers faster way of developing and testing communication services, but keeping care on providing low latency.\nMore on Why Diago"},"title":"_index"},"/diago/docs/api_docs/":{"data":{"":"","answering-call#Answering call":"","bridge#Bridge":"Bridge allows bridging your Dialog Sessions. If dialogs are answered and have media sessions you can bridge them.\nbridge := diago.NewBridge() bridge.AddDialogSession(d1) bridge.AddDialogSession(d2) For now bridge is only doing proxy of RTP and it does not allow Transcoding, although lib supports transcoding.\nTranscoding is generally something you do not want in running system so bridge will return error in case codecs are missmatch. If needed it will be exposed more as special thing.","dialog-sessions#Dialog Sessions":"","early-media#Early Media":"Many systems use early media to announce some activity, but not actually signaling call being answered.\nfunc PlayFile(dialog *diago.DialogServerSession) { if err := dialog.ProgressMedia(); err != nil { fmt.Println(\"Failed to start early\", err) return } // Now media is already open and we can start playing file pb, err := dialog.PlaybackCreate() if err != nil { fmt.Println(\"Failed to create playback\", err) return } if err := pb.PlayUrl(\"https://mycoolaudio.wav\"); err != nil { fmt.Println(\"Playing failed\", err) } // Continue with answering call dialog.Answer() } ","incoming-call#Incoming call":"","media-handling#Media handling":"","outgoing-call#Outgoing call":"","playback#Playback":"","recording#Recording":"Library API tries to be well documented through comments. For more reference visit GO DOC\nHere we explain some of main built in concepts and usage.\nDialog Sessions diago can act as UAS(User Agent Server) and UAC(User Agent Client), and adds bridging capability to build B2BUA services.\nIt intentionally distincts dialog received (Acting as server) and dialog created (Acting as client):\nDialogServerSession when receving incoming dialog (SIP INVITE) and setups session (media) DialogClientSession when it creates outgoing dialog (SIP INVITE) and setups session (media) For best understanding here some docs with short code reference.\nSetup Diago needs instance to be created NewDiago or in other words instance represents single UserAgent.\nWith this instance you can serve multiple incoming dialogs or dial destinations in parallel.\nua, _ := sipgo.NewUA() dg := diago.NewDiago(ua) Customize SIP Transport Diago allows you to customize transport listeners with WithTransport Below example makes diago only listen for TCP SIP.\ntransportTCP := diago.Transport{ Transport: \"tcp\", BindHost: \"127.0.0.1\", BindPort: 5060, } dg := diago.NewDiago(ua, diago.WithTransport(transportTCP), ) Transport support: UDP, TCP, TLS, WS, WSS\nFor more configuration checkout github.com/emiago/diago#Transport\nIncoming call Calling Serve allows to serve every new call. Here you can build you routing by accessing dialog. Some of helpers are added\nToUser - destination callerID FromUser - from callerID Transport - transport of SIP message See example below.\ndg.Serve(ctx, func(inDialog *diago.DialogServerSession) { // - Do your call routing. switch inDialog.ToUser() { case \"play\" // PlayFile(inDialog) case \"answer\": // Answer(inDialog) case \"123456\" } // inDialog is scope limited, exiting this routine will Close dialog. // Use Context to hold dialog in routine \u003c-inDialog.Context().Done() }) NOTE: Dialog created is scoped (Like HTTP request serving). Once dialog exists, it is cleaned up, so no further action is needed.\nOutgoing call Invite sends SIP INVITE and waits for answer. After succesfull answer you can apply many other actions for dialog.\ndialog, err := dg.Invite(ctx, recipient sip.Uri, opts diago.InviteOptions) if err != nil { // Handle err. Special ErrDialogResponse is returned if non 200 is received } defer dialog.Close() // Closing outgoing dialog is needed // Do something // Hangup dialog.Hangup() For more controled dialog handling, checkout out NewDialog which allows you to create dialog and media stack before doing INVITE.\nAnswering call func Answer(inDialog *diago.DialogServerSession) { inDialog.Trying() // Trying -\u003e 100 Trying inDialog.Ringing() // Ringing -\u003e 180 Response if err := inDialog.Answer(); err != nil { fmt.Println(\"Failed to answer\", err) return } ctx := inDialog.Context() select { case \u003c-ctx.Done(): // Callee hangup case \u003c-time.After(1 * time.Minute): // Caller hangup inDialog.Hangup(ctx) } } Media handling Every session comes with 2 streams (Audio for now). In diago case it is referenced as reader/writer.\nAudioReader reads incoming stream AudioWriter writes outgoing stream Normally you mostly deal with writing audio so Playback is created for easier dealing with audio streams.\nNOTE: Diago does not automatically reads audio stream in background. This can happen with explicit call or bridging.\nPlayback Playing audio file is done with audio playback. Library provides prebuilt playback functionality\nPlayback can:\nPlay File (wav/PCM) Play any stream (no encoders) Either outgoing or incoming after leg is answered you can create playback\nfunc PlayFile(dialog *diago.DialogServerSession) { // NOTE: It is expected that dialog.Answer() is called playFile, err := os.Open(\"myaudiofile.wav\") if err != nil { return err } defer playFile.Close() pb, err := dialog.PlaybackCreate() if err != nil { fmt.Println(\"Failed to create playback\", err) return } if err := pb.Play(playfile, \"audio/wav\"); err != nil { fmt.Println(\"Playing failed\", err) } } Playback with control If you need to control your playback like Mute Unmute or just to Stop current playback, then you can use AudioPlaybackControl\nfunc PlayFileControled(dialog *diago.DialogClientSession) { // NOTE: It is expected that dialog.Answer() is called pb, err := dialog.PlaybackControlCreate() if err != nil { fmt.Println(\"Failed to create playback\", err) return } go func() { playFile, err := os.Open(\"myaudiofile.wav\") if err != nil { return err } defer playFile.Close() pb.Play(playfile, \"audio/wav\") // Note needs error handling } pb.Mute(true) // Mute/Unmute audio pb.Stop() // Stop playing audio. This will make Play exit } Recording Diago exposes audio recording object which can be used in audio pipeline. Recording is only there once you start reading or writing to the stream.\n// Create wav file to store recording func Record(dialog *diago.DialogServerSession) { // NOTE: It is expected that dialog.Answer() is called wawFile, err := os.OpenFile(\"myrecording.wav\", os.O_RDWR|os.O_CREATE, 0755) if err != nil { return err } defer wawFile.Close() // Create recording audio pipeline rec, err := inDialog.AudioStereoRecordingCreate(wawFile) if err != nil { return err } // Must be closed for correct flushing defer func() { if err := rec.Close(); err != nil { slog.Error(\"Failed to close recording\", \"error\", err) } }() // Do echo until call is hanguped media.Copy(rec.AudioReader(), rec.AudioWriter()) } ","setup#Setup":""},"title":"API Docs"},"/diago/docs/audio_pipelines/":{"data":{"":"","#":"Everything is io.Reader and io.Writer\nDiago follows GO std lib and providing interface for Reader/Writer when it comes reading and writing media. This made easier usage of RTP framework and optimizations, by providing end user standard library io.Reader io.Writer to pass his media.\nIn other words creating reader or writer pipelines allows to build interceptors, encoders, decoders without introducing overhead of contention and buffer reuse.\nmedia and audio package also provide all this helpers for making audio pipelines straightforward. In realtime media streaming, audio is sampled at constant rate.\nSome of io operations you encounter have helpers media package like media.Copy , media.ReadAll, which are better suited instead std io\nCreating Echo Everything mostly begins by getting actual AudioReader and AudioWriter from Dialog Session.\nar, _ := dialog.AudioReader() aw, _ := dialog.AudioWriter() Now you can use this helpers\nn, err := media.Copy(ar, aw) // It creates buffer of media.RTPBufSize For less memory alloc, better option is media.CopyWithBuf where controlling buffer reuse can be made.\nMore audio processing For more audio processing audio (ex transcoding, wav streaming) package provides you with prebuilt helpers for pipelining More you can find here https://pkg.go.dev/github.com/emiago/diago/audio"},"title":"Audio Pipelines"},"/diago/docs/examples/":{"data":{"":"","audio-playback#Audio playback":" ","audio-playback-with-control#Audio playback with control":" ","cli-softphone-for-testing#CLI Softphone for testing":"For testing below scenarios, gophone as CLI softphone is used, but you can use any softphone you like.\nVisit the page and install: https://github.com/emiago/gophone\nSource code of examples is in library. You will need go compiler installed.\nHere we show couple of them","dtmf#DTMF":" "},"title":"Demo     Examples"},"/diago/docs/getting_started/":{"data":{"":"","echo-test-app#Echo test app":"Copy audio file from library testdata/files/demo-echotest.wav or change to whatever you want\nua, _ := sipgo.NewUA() dg := diago.NewDiago(ua) dg.Serve(ctx, func(inDialog *diago.DialogServerSession) { inDialog.Trying() // Trying inDialog.Answer(); // Answer // Make sure file below exists in work dir playfile, err := os.Open(\"demo-echotest.wav\") if err != nil { fmt.Println(\"Failed to open file\", err) return } defer playfile.Close() // Create playback and play file. pb, _ := inDialog.PlaybackCreate() if err := pb.Play(playfile, \"audio/wav\"); err != nil { fmt.Println(\"Playing failed\", err) } } Dial in with softphone on 127.0.0.1:5060 and you should here audio playing.\nWith gophone:\ngophone dial -media=speaker sip:111@127.0.0.1 ","getting-started#Getting started":"As showcase, code below is only needed to start serving Calls. In this example Call will be answered and played some audio.\nFor testing you can use gophone CLI sofpthone built with same libraries or any other SIP softphone."},"title":"getting_started"},"/diago/docs/guides/":{"data":{"":"Understanding VOIP can be a challenge for newcomers, but can it be simple and easier approach?\nVOIP is now mostly built with SIP. SIP is textual protocol same as HTTP so if you know HTTP reading SIP messages will be easy. It acts similar and has similar behavior (request/response) but focus is more on Session. With realtime media like audio/video there is always session after which it ends. Creating, Updating, Clossing this Session is something that SIP is designed\nTo understand and have good debug skills it is important to know how SIP works in different situations. Here I will try to provide some simple documentation to help you BUILDERS.\nNext: Understanding SIP with Call Scenarios"},"title":"Guides"},"/diago/docs/guides/sip_and_media/":{"data":{"":"","undestanding-sip-and-media#Undestanding SIP and media":"INVITE carries SDP (application/sdp) in body of message as offer to explain media capabilites and connection setup. INVITE can have any other type in Body like HTTP, but SDP protocol is mainly used. More about this later.\nAccepting(Answering) call is done by respondin with 200 OK\nResponse carries SDP in body as answer to explain callee’s media capabilites and connection.\nCall with media With SDP we explain our capabilites and protocol used for media and this mostly boils down to this 3 things:\nexplaining which codecs are supported for decoding (alaw,ulaw, opus, g722, …), protocol and profile (RTP AVP). RTP can have different profile but AVP (Audio Video) is used in this case and Listen IP where we expect incoming media (UDP) Returning 200 For realtime media RTP is one mostly used. Anyway in case Bob has no similar capabilities, lets say codecs, Bob will send non 200 response and call will be terminated.\nSending ACK After Caller receiving 200 OK it is required that Caller acknowledge Callee capabilities, by sending ACK (non transactional, no response) request.\nCodecs Codecs or in other words Formats are identified as numbers. There are static defined by AVP profile or user can have any other defined with own custom numbers. In above case we use statically defined.\n0 ulaw 8000Hz 8 alaw 8000Hz In SDP this will be shown as m=desc key. Ex:\nm=audio 49170 RTP/AVP 0 8\nDescription:\naudio: type of stream 49170: port on which is listening RTP/AVP: identifier for RTP protocol and AVP denotes as Audio Video 0: is codec identifier Normally this should be followed with a=rtpmap attributes to explain about codecs. In case static this is not required.\nListen IP Information and where device/use is listening for incoming media traffic c=IN IP4 198.51.100.1\nIP4 denotes IP version 4 is used With nowdays NAT this unfortunatelly makes problem, as you can expect end user behind NAT will publish his private IP like 192.168.1.1. This is solved in different ways, but for now we will stop here. Other problem is if call is jumping between media servers, above can be changed with new IP received via new INVITE messaging.\nNOTE: Publishing local IP like above is problem for NAT and there different approaches to solve this issue, but for now we will skip this part."},"title":"SIP and Media"},"/diago/docs/guides/understanding_rtp/":{"data":{"":"","understanding-rtp#Understanding RTP":"Here we may go deep dive for some RTP concepts\nRTP Timestamp RTP timestamp follows sampling clock rate which is not the same as following Real Time duration.\nEvery audio stream will have constant RTP Timestamp increase based on samples generated, but in case of stopping current stream and starting new, this RTP timestamp difference must be calculated.\nValue should not be based whether streamer is slow or fast in pushing RTP packets\nRTP Timestamp when pause or no audio present So in case you have pauses in audio stream, RTP timestamp still need to continue and recalculated based on Real Time. If RTP timestamp is not recalculated it will affect RTCP metrics as well and therefore wrong calc of jitter and etc.\nIn case of non Real Time audio, like streaming pre downloaded audio, sampling must still apply. This means many packets may be sent at once, but RTP timestamp will be virtually increased.\nRTP Timestamp modifications visual Stream Write: Timestamp = 0; increase += 160 (20ms Sample duration)\nStream Stop: Timestamp = 1600; Written = 10 Frames/Samples\nPause: 100ms = 5 * 160 = 800\nStream Write: Timestamp = 1600 + 800 = 2400; increase += 160 (20ms Sample duration)"},"title":"Understanding RTP"},"/diago/docs/guides/understanding_sip/":{"data":{"":"","#":"Every call starts with INVITE SIP Messages. Here is how to relate SIP message to PHONE actions\nDialing = INVITE Answer = 200 OK response on INVITE Hangup = BYE Cancel = CANCEL Reject = 486 Busy INVITE is creating session which we call dialog.\nCaller (Client): Sends one time ACK as confirmation\nSuccesfull call Example of alice inviting bob\nINVITE sip:bob@127.0.0.1:5060 SIP/2.0 Via: SIP/2.0/udp 127.0.0.99:50725;branch=z9hG4bK.pgb382qZ312tyXIP Content-Type: application/sdp Content-Length: 235 Contact: \u003csip:alice@127.0.0.99:50725\u003e;transport=udp From: \"alice\" \u003csip:alice@127.0.0.99\u003e;tag=hImscoj6Jew8y6da To: \u003csip:bob@127.0.0.1\u003e Call-ID: 729cd7dd-96dc-419b-b339-327c60dfc2d7 CSeq: 1 INVITE Max-Forwards: 70 Succesfull call with provisional responses (More realistic) Call establishment can take a while, so provisional responses help with this.\nProvisional responses = 1xx and mostly you will see 100 and 180. 100 is used in HTTP as well, it just notifies client that request is accepted but it is in progress.\nAfter very quickly you may have Ringing, which indicates that end user device is reached and it is ringing.\nCanceling call with SIP CANCEL Caller cancels call by sending CANCEL msg. It must contain same headers as INVITE for matching transcaction.\nCANCEL is new transaction request like INVITE which receives response, but SIP uses this request to try match existing INVITE transaction. That is why 200 OK is replied\nOnce Bob finds matching transcation it terminates and sends respond to INVITE with 487 Request terminated\nTO BE CONTINUED"},"title":"Understading SIP with Call Scenarios"},"/diago/docs/media_codecs/":{"data":{"":"","#":"Diago for now is only built for audio processing to target VOIP needs, but it may support video as well.\nSDP negotiation You can control codecs support with media conf and there order. Checkout for diago.MediaConfig which can be passed on creating diago.\nSupported codecs:\nPCMU (ulaw) PCMA (alaw) opus Opus Library uses opus C binding and it is not enabled by default You need to have installed opus development files before compiling.\nExample for linux:\nUbuntu:\nsudo apt-get install pkg-config libopus-dev libopusfile-dev Fedora:\nsudo dnf install opus-devel opusfile-devel Opus compile To enable opus compile you need to place build tags.\ngo build -tags with_opus_c . Make sure you have enabled opus with diago.MediaConfig and passing media.CodecAudioOpus. Example:\ndiago.MediaConfig{ Codecs: []string(media.CodecAudioOpus, media.CodecAudioAlaw), } For more on how to compile checkout this package https://github.com/hraban/opus"},"title":"media_codecs"},"/diago/docs/why_diago/":{"data":{"":"Development of VOIP services can be slow or it was full workarounds. Diago try to offer more modern Stack and put you closer to protocol,network,media but offering High level and low level API calls.\nDiago is built with GO language. We are keeping well optimized sip and media stack to have performance and low GC latency. Major win is Go offers fast development speed and memory safety, but also tooling to tweak best performance.\nIn case you wondering is Go right language, there are already good benchmark results with just sipgo proxysip benchmarks."},"title":"why_diago"}}