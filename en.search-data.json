{"/diago/blog/":{"data":{"":"\nWelcome to blog where you can find some interesting topics or how to use some of VOIP stack features."},"title":"_index"},"/diago/blog/unit_testing/":{"data":{"":"","#":"How to UNIT test server First make sure you have imported siptest\nimport \"github.com/emiago/sipgo/siptest\" Example with testing REGISTER request\nfunc handleRegister(req *sip.Request, tx sip.ServerTransaction) { res := sip.NewResponseFromRequest(req, sip.StatusBadRequest, \"Bad Request\", nil) tx.Respond(res) } func TestServerHandlers(t *testing.T) { // Setup server uas, _ := sipgo.NewUA() srv, _ := sipgo.NewServer(uas) srv.OnRegister(handleRegister) // Create request req := sip.NewRequest(sip.REGISTER, sip.Uri{User: \"alice\", Host: \"localhost\"}) // Use dummy client to build request headers uac, _ := sipgo.NewUA() client, _ := sipgo.NewClient(uac) sipgo.ClientRequestBuild(client, req) // Create transaction Recorder txRecord := siptest.NewServerTxRecorder(req) // Run handler and read response handleRegister(req, txRecord) responses := txRecord.Result() require.Len(t, responses, 1) assert.EqualValues(t, 400, responses[0].StatusCode) } "},"title":"unit_testing"},"/diago/docs/":{"data":{"":"Welcome to diago documentation!.","core-roadmap#Core (Roadmap):":" Full dialog control and High Level API alaw,ulaw codecs (opus as third is planned as well) Audio package for streaming: WAV reader/writer, PCM transcoding to alaw/ulaw Playbacks as buffers,files(wav),url Playback URL streaming Playback with control mute/unmute Audio Reader/Writer stream exposed for manual processing like sending to third party DTMF with RTP Handling Reinvites with media updates Bridging as proxy media for 2 parties B2BUA Opus codec support Handling transfers (Refers) Handle Anonymous Trust Domain PAI handling (rfc3325) Conferencing audio DTMF with SIP INFO (Needed more in case webrtc) Writing Unit Test on Server with SIP and Media Recorder RTP symetric SRTP for more critical services Simple Wav recording Webrtc as media stack (integration with pion) Full IPV6 support (sipgo work) And plenty more … If you want support/sponzor current development roadmap or you want to prioritize different contact me on mail","diago-extra-modules#Diago extra modules":"Some of modules are not yet considered to be part of lib and they are developed/consulted for private projects. To mention few:\nRecording Webrtc(pion) stack over diago’s media stack Complex modules etc… NEXT: -\u003e Guides","what-is-diago#What is Diago?":"If you are familiar with terms Calling, Bridging, Conferencing, IVR, Recording, Transcribing, Voicemail … that is all about.\nDeveloping this kind of services can be challenging when it needs more behavior: monitoring, media control, integrations, databases etc…\nDiago with GO offers faster way of developing and testing communication services, but keeping care on providing low latency.\nMore on Why Diago"},"title":"_index"},"/diago/docs/api_docs/":{"data":{"":"Library API tries to be well documented through comments. For more reference visit GO DOC\nHere we explain some of main built in concepts and usage.","answering-call#Answering call":" func Answer(inDialog *diago.DialogServerSession) { inDialog.Progress() // Progress -\u003e 100 Trying inDialog.Ringing() // Ringing -\u003e 180 Response if err := inDialog.Answer(); err != nil { fmt.Println(\"Failed to answer\", err) return } ctx := inDialog.Context() select { case \u003c-ctx.Done(): case \u003c-time.After(1 * time.Minute): } } ","bridge#Bridge":"Bridge allows bridging your Dialog Sessions. If dialogs are answered and have media sessions you can bridge them.\nbridge := diago.NewBridge() bridge.AddDialogSession(d1) bridge.AddDialogSession(d2) For now bridge is only doing proxy of RTP and it does not allow Transcoding.\nTranscoding is generally something you do not want in running system so bridge will return error in case codecs are missmatch.","dialog-sessions#Dialog Sessions":"diago can act as UAS(User Agent Server) and UAC(User Agent Client), and adds bridging capability to build B2BUA services.\nIt intentionally distincts dialog received (Acting as server) and dialog created (Acting as client):\nDialogServerSession when receving incoming dialog (SIP INVITE) and setups session (media) DialogClientSession when it creates outgoing dialog (SIP INVITE) and setups session (media) For best understanding here some docs with short code reference.","incoming-call#Incoming call":"Calling Serve allows to serve every new call. Here you can build you routing by accessing dialog. Some of helpers are added\nToUser - destination callerID FromUser - from callerID Transport - transport of SIP message See example below.\ndg.Serve(ctx, func(inDialog *diago.DialogServerSession) { // - Do your call routing. switch inDialog.ToUser() { case \"answer\": case \"123456\" } // inDialog is scope limited, exiting this routine will Close dialog. // Use Context to hold dialog in routine \u003c-inDialog.Context().Done() }) NOTE: Dialog created is scoped (Like HTTP request serving). Once dialog exists, it is cleaned up, so no further action is needed.","media-handling#Media handling":"Every session comes with 2 streams (Audio for now). In diago case it is referenced as reader/writer.\nAudioReader reads incoming stream AudioWriter writes outgoing stream Normally you mostly deal with writing audio so Playback is created for easier dealing with audio streams.\nNOTE: Diago does not automatically reads audio stream in background. This can happen with explicit call or bridging.","outgoing-call#Outgoing call":"Invite sends SIP INVITE and waits for answer. After succesfull answer you can apply many other actions for dialog.\ndialog, err := dg.Invite(ctx, recipient sip.Uri, opts diago.InviteOptions) if err != nil { // Handle err. Special ErrDialogResponse is returned if non 200 is received } defer dialog.Close() // Closing outgoing dialog is needed // Do something // Hangup dialog.Hangup() ","playback#Playback":"Playing audio file is done with audio playback. Library provides prebuilt playback functionality\nPlayback can:\nPlay File (wav/PCM) Play any stream (no encoders) Either outgoing or incoming after leg is answered you can create playback\npb, err := dialog.PlaybackCreate() if err != nil { fmt.Println(\"Failed to create playback\", err) return } if err := pb.Play(playfile, \"audio/wav\"); err != nil { fmt.Println(\"Playing failed\", err) } } Playback with control If you need to control your playback like Mute Unmute or just to Stop current playback, then you can use AudioPlaybackControl\npb, err := dialog.PlaybackControlCreate() if err != nil { fmt.Println(\"Failed to create playback\", err) return } go pb.Play(playfile, \"audio/wav\") // Note needs error handling pb.Mute(true) // Mute/Unmute audio pb.Stop() // Stop playing audio. This will make Play exit } ","setup#Setup":"Diago needs instance to be created NewDiago or in other words instance represents single UserAgent.\nWith this instance you can serve multiple incoming dialogs or dial destinations in parallel.\nua, _ := sipgo.NewUA() dg := diago.NewDiago(ua) Customize SIP Transport Diago allows you to customize transport listeners with WithTransport Below example makes diago only listen for TCP SIP.\ntransportTCP := diago.Transport{ Transport: \"tcp\", BindHost: \"127.0.0.1\", BindPort: 5060, } dg := diago.NewDiago(ua, diago.WithTransport(transportTCP), ) Transport support: UDP, TCP, TLS, WS, WSS\nFor more configuration checkout GO Docs"},"title":"API Docs"},"/diago/docs/examples/":{"data":{"":"","audio-playback#Audio playback":" ","audio-playback-with-control#Audio playback with control":" ","cli-softphone-for-testing#CLI Softphone for testing":"For testing below scenarios, gophone as CLI softphone is used, but you can use any softphone you like.\nVisit the page and install: https://github.com/emiago/gophone\nSource code of examples is in library. You will need go compiler installed.\nHere we show couple of them","dtmf#DTMF":" "},"title":"Demo     Examples"},"/diago/docs/getting_started/":{"data":{"":"","echo-test-app#Echo test app":"Copy audio file from library testdata/files/demo-echotest.wav or change to whatever you want\nua, _ := sipgo.NewUA() dg := diago.NewDiago(ua) dg.Serve(ctx, func(inDialog *diago.DialogServerSession) { inDialog.Progress() // Progress -\u003e 100 Trying inDialog.Answer(); // Answer // Make sure file below exists in work dir playfile, err := os.Open(\"demo-echotest.wav\") if err != nil { fmt.Println(\"Failed to open file\", err) return } defer playfile.Close() // Create playback and play file. pb, _ := inDialog.PlaybackCreate() if err := pb.Play(playfile, \"audio/wav\"); err != nil { fmt.Println(\"Playing failed\", err) } } Dial in with softphone on 127.0.0.1:5060 and you should here audio playing.\nWith gophone:\ngophone dial -media=speaker sip:111@127.0.0.1 ","getting-started#Getting started":"As showcase, code below is only needed to start serving Calls. In this example Call will be answered and played some audio.\nFor testing you can use gophone CLI sofpthone built with same libraries or any other SIP softphone."},"title":"getting_started"},"/diago/docs/guides/":{"data":{"":"Understanding VOIP can be a challenge for newcomers, but can it be simple and easier approach?\nVOIP is now mostly built with SIP. SIP is textual protocol same as HTTP so if you know HTTP reading SIP messages will be easy. It acts similar and has similar behavior (request/response) but focus is more on Session. With realtime media like audio/video there is always session after which it ends. Creating, Updating, Clossing this Session is something that SIP is designed\nTo understand and have good debug skills it is important to know how SIP works in different situations. Here I will try to provide some simple documentation to help you BUILDERS.\nNext: Understanding SIP with Call Scenarios"},"title":"Guides"},"/diago/docs/guides/sip_and_media/":{"data":{"":"","undestanding-sip-and-media#Undestanding SIP and media":"INVITE carries SDP (application/sdp) in body of message as offer to explain media capabilites and connection setup. INVITE can have any other type in Body like HTTP, but SDP protocol is mainly used. More about this later.\nAccepting(Answering) call is done by respondin with 200 OK\nResponse carries SDP in body as answer to explain callee’s media capabilites and connection.\nCall with media With SDP we explain our capabilites and protocol used for media and this mostly boils down to this 3 things:\nexplaining which codecs are supported for decoding (alaw,ulaw, opus, g722, …), protocol and profile (RTP AVP). RTP can have different profile but AVP (Audio Video) is used in this case and Listen IP where we expect incoming media (UDP) Returning 200 For realtime media RTP is one mostly used. Anyway in case Bob has no similar capabilities, lets say codecs, Bob will send non 200 response and call will be terminated.\nSending ACK After Caller receiving 200 OK it is required that Caller acknowledge Callee capabilities, by sending ACK (non transactional, no response) request.\nCodecs Codecs or in other words Formats are identified as numbers. There are static defined by AVP profile or user can have any other defined with own custom numbers. In above case we use statically defined.\n0 ulaw 8000Hz 8 alaw 8000Hz In SDP this will be shown as m=desc key. Ex:\nm=audio 49170 RTP/AVP 0 8\nDescription:\naudio: type of stream 49170: port on which is listening RTP/AVP: identifier for RTP protocol and AVP denotes as Audio Video 0: is codec identifier Normally this should be followed with a=rtpmap attributes to explain about codecs. In case static this is not required.\nListen IP Information and where device/use is listening for incoming media traffic c=IN IP4 198.51.100.1\nIP4 denotes IP version 4 is used With nowdays NAT this unfortunatelly makes problem, as you can expect end user behind NAT will publish his private IP like 192.168.1.1. This is solved in different ways, but for now we will stop here. Other problem is if call is jumping between media servers, above can be changed with new IP received via new INVITE messaging.\nNOTE: Publishing local IP like above is problem for NAT and there different approaches to solve this issue, but for now we will skip this part."},"title":"SIP and Media"},"/diago/docs/guides/understanding_sip/":{"data":{"":"","#":"Every call starts with INVITE SIP Messages. Here is how to relate SIP message to PHONE actions\nDialing = INVITE Answer = 200 OK response on INVITE Hangup = BYE Cancel = CANCEL Reject = 486 Busy INVITE is creating session which we call dialog.\nCaller (Client): Sends one time ACK as confirmation\nSuccesfull call Example of alice inviting bob\nINVITE sip:bob@127.0.0.1:5060 SIP/2.0 Via: SIP/2.0/udp 127.0.0.99:50725;branch=z9hG4bK.pgb382qZ312tyXIP Content-Type: application/sdp Content-Length: 235 Contact: \u003csip:alice@127.0.0.99:50725\u003e;transport=udp From: \"alice\" \u003csip:alice@127.0.0.99\u003e;tag=hImscoj6Jew8y6da To: \u003csip:bob@127.0.0.1\u003e Call-ID: 729cd7dd-96dc-419b-b339-327c60dfc2d7 CSeq: 1 INVITE Max-Forwards: 70 Succesfull call with provisional responses (More realistic) Call establishment can take a while, so provisional responses help with this.\nProvisional responses = 1xx and mostly you will see 100 and 180. 100 is used in HTTP as well, it just notifies client that request is accepted but it is in progress.\nAfter very quickly you may have Ringing, which indicates that end user device is reached and it is ringing.\nCanceling call with SIP CANCEL Caller cancels call by sending CANCEL msg. It must contain same headers as INVITE for matching transcaction.\nCANCEL is new transaction request like INVITE which receives response, but SIP uses this request to try match existing INVITE transaction. That is why 200 OK is replied\nOnce Bob finds matching transcation it terminates and sends respond to INVITE with 487 Request terminated\nTO BE CONTINUED"},"title":"Understading SIP with Call Scenarios"},"/diago/docs/media_codecs/":{"data":{"":"","#":"Diago for now is only built for audio processing to target VOIP needs, but it may support video as well.\nSDP negotiation You can control codecs support with media conf and there order. Checkout for diago.MediaConfig which can be passed on creating diago.\nIf you need transcoding library for now supports this codecs:\nPCMU (ulaw) PCMA (alaw) opus Opus Library uses opus C binding and it is not enabled by default You need to have installed opus development files before compiling.\nExample for linux:\nUbuntu:\nsudo apt-get install pkg-config libopus-dev libopusfile-dev Fedora:\nsudo dnf install opus-devel opusfile-devel Opus compile To enable opus compile you need to place build tags.\ngo build -tags with_opus_c . Make sure you have enabled opus with diago.MediaConfig and passing sdp.FORMAT_TYPE_OPUS. Example:\ndiago.MediaConfig{ Formats: []string(sdp.FORMAT_TYPE_OPUS, sdp.FORMAT_TYPE_ALAW, sdp.FORMAT_TYPE_ULAW), } For more on how to compile checkout this package https://github.com/hraban/opus"},"title":"media_codecs"},"/diago/docs/why_diago/":{"data":{"":"Development of VOIP services can be slow or it was full workarounds. Diago try to offer more modern Stack and put you closer to protocol,network,media but offering High level and low level API calls.\nDiago is built with GO language. We are keeping well optimized sip and media stack to have performance and low GC latency. Major win is Go offers fast development speed and memory safety, but also tooling to tweak best performance.\nIn case you wondering is Go right language, there are already good benchmark results with just sipgo proxysip benchmarks."},"title":"why_diago"}}